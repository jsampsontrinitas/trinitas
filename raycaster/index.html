<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Raycaster Demo</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #222;
        }

        body {
            height: 100vh;
            display: flex;
            align-items: center;
        }

        #game {
            width: 100vw;
            height: 100vh;
            display: flex;
            margin: 0 auto;
            align-items: center;
            box-shadow: 0 1em 3em rgba(0, 0, 0, 0.5);
            background-image: linear-gradient(to bottom, #72aaf3 50%, #222 50%);
        }

        .ray {
            flex: 1;
            background: black;
            height: 50%;
        }

        #minimap {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #fff;
            transform-origin: bottom left;

            &:hover {
                transform: scale(2);
            }
        }
    </style>
</head>

<body>
    <canvas id="minimap" width="200" height="200"></canvas>
    <div id="game"></div>

    <script>
        const game = document.getElementById('game');
        const minimap = document.getElementById('minimap');
        const ctx = minimap.getContext('2d');
        const rays = [];
        const numRays = 56; //512;

        for (let i = 0; i < numRays; i++) {
            const div = document.createElement('div');
            div.classList.add('ray');
            game.appendChild(div);
            rays.push(div);
        }


        const small_map = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 1, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        const big_map = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1],
            [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        /* We have a couple maps to choose from. Which one should we use?
        We'll call the `Math.random()` function to decide. If it generates
        a number less-than or equal-to 0.5, we'll use the `big_map`. Otherwise
        we will use the `small_map`. We use a "ternary operator" here as a
        small, concise "if statement" of sorts. */
        const map = (Math.random() <= 0.5) ? big_map : small_map;

        const mapHeight = map.length;
        const mapWidth = map[0].length;

        function castRays() {
            for (let i = 0; i < numRays; i++) {
                const rayAngle = (player.angle - player.fov / 2) + (i / numRays) * player.fov;

                const rayX = Math.cos(rayAngle);
                const rayY = Math.sin(rayAngle);

                let mapX = Math.floor(player.x);
                let mapY = Math.floor(player.y);

                const deltaDistX = Math.abs(1 / rayX);
                const deltaDistY = Math.abs(1 / rayY);

                let sideDistX, sideDistY;
                let stepX, stepY;

                if (rayX < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; }
                else { stepX = 1; sideDistX = (mapX + 1 - player.x) * deltaDistX; }

                if (rayY < 0) { stepY = -1; sideDistY = (player.y - mapY) * deltaDistY; }
                else { stepY = 1; sideDistY = (mapY + 1 - player.y) * deltaDistY; }

                let hit = false;
                let hitVertical = false;

                while (!hit) {
                    if (sideDistX < sideDistY) {
                        sideDistX += deltaDistX;
                        mapX += stepX;
                        hitVertical = true;
                    } else {
                        sideDistY += deltaDistY;
                        mapY += stepY;
                        hitVertical = false;
                    }

                    if (mapX < 0 || mapX >= mapWidth || mapY < 0 || mapY >= mapHeight || map[mapY][mapX] === 1) {
                        hit = true;
                    }
                }

                const distance = hitVertical
                    ? (sideDistX - deltaDistX)
                    : (sideDistY - deltaDistY);


                // Closer walls are brighter; walls are darker the further away they are.
                // We have a max brightness of 0.85 and a min brightness of 0.25. We assume a max distance of 10.
                // The brightness is calculated as a function of the distance from the player to the wall.
                const shading = Math.max(0.25, Math.min(0.85, 1 - (distance / 10)));

                // Correct fish-eye effect
                const correctedDistance = distance * Math.cos(rayAngle - player.angle);

                rays[i].dataset.angle = rayAngle;
                rays[i].dataset.distance = distance;
                rays[i].style.height = Math.min(100 / correctedDistance, 100) + "%";

                const wallColor = hitVertical
                    ? `rgb(${[139, 69, 19].map(x => x * shading).join(',')})`
                    : `rgb(${[112, 128, 144].map(x => x * shading).join(', ')})`;

                rays[i].style.background = wallColor;
            }
        }

        /* We create a "state" object to set our player's initial location,
        angle, and more. We'll read from this to know where the user is, and
        write to it to state where the user ought to be. "fov" is where we
        track the player's "field of view", or how much the user can see
        side-to-side without turning left or right. */
        const player = { x: 1.5, y: 1.5, angle: 0, fov: Math.PI / 3 };

        /* To control our player/camera, we need to know what keys are being
        pressed at any given time. We'll create a "Set" (which is like an array
        but doesn't permit duplicate entries) to track which keys are pressed. */
        const pressedKeys = new Set();

        // When a key is pressed down, we'll add that key to our set
        window.addEventListener('keydown', (e) => pressedKeys.add(e.key));

        // When a key is released, we'll remove it from our set
        window.addEventListener('keyup', (e) => pressedKeys.delete(e.key));

        /* This function determines the next player position based on the
        current position, angle, and move-distance of the player. It is called
        once for every frame update, and evaluates the state of keyboard input
        such as whether or not the ArrowLeft or ArrowUp keys are being pressed. */
        function updatePlayerPosition() {
            /* The current location of our player is stored on the player
            object under properties `x` and `y`. We don't want to change them
            immediately, so we'll create temporary variables that track the
            next potention location of our player. We can see if these variables
            ultimately reflect a permitted move (stepping further into a room)
            or not (stepping through a wall). If the new values ultimately look
            good, we will use them to overwrite the `player.x` and `player.y`. */
            let moveStep = 0.1;
            let nextX = player.x;
            let nextY = player.y;

            // Update the potential x/y position based on possible "strafing"
            // Strafing is when the player steps side to side without turning
            if (pressedKeys.has('a') || pressedKeys.has('d')) {
                const strafeAngle = player.angle + Math.PI / 2;
                const strafeMoveStep = 0.05;
                const strafeDirection = pressedKeys.has('a') ? -1 : 1;
                nextX += Math.cos(strafeAngle) * strafeMoveStep * strafeDirection;
                nextY += Math.sin(strafeAngle) * strafeMoveStep * strafeDirection;
            }

            // Pressing the left/right arrows changes our angle very slightly
            if (pressedKeys.has('ArrowLeft')) { player.angle -= 0.1; }
            if (pressedKeys.has('ArrowRight')) { player.angle += 0.1; }

            // Update the potential x/y position based on the user's desire
            // to walk forward (by pressing the Up arrow or the W key).
            if (pressedKeys.has('ArrowUp') || pressedKeys.has('w')) {
                nextX += Math.cos(player.angle) * moveStep;
                nextY += Math.sin(player.angle) * moveStep;
            }

            // Likewise, update the potential x/y position based on the user's
            // signal to walk backwards using Down Arrow or S key.
            if (pressedKeys.has('ArrowDown') || pressedKeys.has('s')) {
                nextX -= Math.cos(player.angle) * moveStep;
                nextY -= Math.sin(player.angle) * moveStep;
            }

            // Now we can check if the potential X/Y coordinates are "walkable"
            // and reflect a space wherein the player is permitted to move. We
            // have a custom function to make this determination.
            if (isWalkable(nextX, nextY)) {
                // If the `isWalkable(...)` function returned true, overwrite
                // our player's X and Y coordinates to their new location!
                player.x = nextX;
                player.y = nextY;
            }
        }

        /* This is our custom function which determines whether or not a set of
        coordinates maps to a square/index in our array that is walkable. This is
        pretty basic right now, checking only if the array value at that location
        is a 0, but we could expand to make all sorts of considerations. We could
        use a value like 3 to encod "lava", and make that non-walkable! */
        function isWalkable(x, y) {
            // Arrays of whole-number indexes (e.g., 0, 1, 2, ...) so we round
            // the coordinates down using the Math.floor() method. If we pass-in
            // a value like 12.82, we will get out 12. This enables us to look-up
            // an array entry value using the rounded values for the index.
            const floorX = Math.floor(x);
            const floorY = Math.floor(y);

            // Because our map is an "array of arrays," we use two sets of square
            // brackets to first target the row, and then the desired cell in the
            // row. We return `true` or `false` based on whether or not the value
            // in our `map[floorY][floorX]` location is equal to the number 0.
            return map[floorY][floorX] === 0;
        }

        /* When the user clicks on the game we want to capture control of
        their mouse (i.e., their "pointer"). We use a feature of the browser
        called "pointer lock" to hide the mouse, and use it for input until
        the user presses the ESC key on their keyboard. */
        game.addEventListener('click', game.requestPointerLock);

        const sensitivity = 0.002; // Adjust for a more/less sensitive mouse

        /* When `game.requestPointerLock` gets called this triggers an event
        on the document called the `pointerlockchange` event. We provide our
        anonymous arrow function to decide what to do if/when this event is
        observed on the document. This means our function will be invoked
        anytime the 'pointerlockchange' event is fired. */
        document.addEventListener('pointerlockchange', () => {
            // If the "game" element is taking control of the pointer
            if (document.pointerLockElement === game) {
                // We handle "mousemove" events with our onMouseMove function
                document.addEventListener('mousemove', onMouseMove);
            } else {
                // If the "game" element has no control of the pointer
                // we remove our event listener, no longer handling movement
                document.removeEventListener('mousemove', onMouseMove);
            }
        });

        /* We'll define a function called onMouseMove that, when called in
        response to a move-movement by the user, will enable us to modify the
        user's angle in the game. This function does nothing until we bind it
        as the handler for "mousemove" events. */
        function onMouseMove(event) {
            // Increase angle by product of mouse movement and sensitivity
            player.angle += event.movementX * sensitivity;

            // Let's keep our angle between 0 and 2π for reliable math, etc.
            if (player.angle < 0) {
                // Increase angle by 2π using special Math.PI "constant"
                player.angle += Math.PI * 2;
            } else if (player.angle >= Math.PI * 2) {
                // Decrease angle by 2π using same special constant
                player.angle -= Math.PI * 2;
            }
        }

        /* The following is an event listener that handles "click" events on
        our minimap (the small representation of our map in the corner). This
        click handler enables us to modify our map as we play it. To achieve
        this, we have to know where the user clicked, and map that to an index
        in the array that represents our map. We can leverage the "event" object
        to determine where the click occured. */
        minimap.addEventListener('click', (event) => {
            /* We can determine the size of our minimap squares by dividing the
            map's complete pixel width by the number of array values in each
            row of the map. Our map is an array of arrays, where the entire
            array consists of "row arrays" (i.e., arrays that represent each
            row of the map).
               
            We can access the first row via its 0 index, and count the number
            of values to determine how many square exist in our map. So if the
            map itself is 200px wide, and consists of a 20-value array for each
            row, then our cellSize would be 200/20. We then use Math.floor() to
            round down the region we clicked into one of those cells.
               
            So if we clicked at coordinates 78.5px,120.3px, we wind up with:
                x =  7 (Math.floor(  78.5/10 )) and
                y = 12 (Math.floor( 120.3/10 ))

            We can then use coordinants 7x12 to check our array to determine
            what type of values (e.g., a 0 or a 1) is in that location. */
            const cellSize = minimap.width / map[0].length;
            const x = Math.floor(event.offsetX / cellSize);
            const y = Math.floor(event.offsetY / cellSize);

            // We don't permit modifications to the first or last rows
            if ( x > 0 && x < mapWidth - 1 ) {
                // Nor do we permit modifications to the top or bottom rows
                if ( y > 0 && y < mapHeight - 1 ) {
                    // We'll retrieve and store the current value of the index
                    const currentValue = map[y][x];
                    // Assign a new value based on the currentValue
                    // This line uses a "ternary operator" - read more on MDN
                    map[y][x] = (currentValue == 0) ? 1 : 0;
                }
            }
        });

        function drawMinimap() {
            ctx.clearRect(0, 0, minimap.width, minimap.height);

            const cellSize = minimap.width / mapWidth;
            const playerSize = cellSize * 0.2; // Player size in minimap
            const playerX = player.x * cellSize;
            const playerY = player.y * cellSize;
            const playerAngle = player.angle * (180 / Math.PI); // Convert to degrees

            // Draw map
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (map[y][x] === 1) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw rays
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < numRays; i++) {
                const rayAngle = rays[i].dataset.angle;
                const rayLength = rays[i].dataset.distance;
                const endX = player.x * cellSize + Math.cos(rayAngle) * rayLength * cellSize;
                const endY = player.y * cellSize + Math.sin(rayAngle) * rayLength * cellSize;
                ctx.beginPath();
                ctx.moveTo(playerX, playerY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }

            // Draw player
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(playerX, playerY, playerSize, 0, Math.PI * 2);
            ctx.fill();

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            for (let x = 0; x < mapWidth; x++) {
                ctx.beginPath();
                ctx.moveTo(x * cellSize, 0);
                ctx.lineTo(x * cellSize, minimap.height);
                ctx.stroke();
            }

            for (let y = 0; y < mapHeight; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * cellSize);
                ctx.lineTo(minimap.width, y * cellSize);
                ctx.stroke();
            }

            // Draw player coordinates and angle to bottom-center of minimap
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            const X = player.x;
            const Y = player.y;
            const A = (player.angle * 180 / Math.PI).toFixed(0);
            const V = (player.fov * 180 / Math.PI).toFixed(0);
            const F = Math.round(1000 / (performance.now() - config.lastTime));

            const text = `X: ${X.toFixed(2)} Y: ${Y.toFixed(2)} A: ${A}° V: ${V}° F: ${F}`;
            const textWidth = ctx.measureText(text).width;

            ctx.fillText(text, minimap.width / 2 - textWidth / 2, minimap.height - 8);
        }

        /* Computers are super fast, and if we let them run our gameLoop as fast as they
        would like, it would be difficult to move our character around in the map. We
        move our character by a fixed amount every time the screen is drawn. To stop
        the character from zipping around too quickly we will control the number of
        times the screen can be drawn in a 1s window. We will cap it at 30 frames per
        second. We'll record the "lastTime" the screen was updated, as well as the
        desired frames per second ("fps"). We measure this in milliseconds, so we do
        a bit of simple division to find the final number. */
        const config = { lastTime: 0, fps: 1000 / 30 };

        /* This is our "Game Loop"; the main loop that runs over and over, causing our
        game to come alive, and update smoothly as though it were a video. Each time
        the loop runs we update the screen with the position of elements, colors, and
        more. Each run is like a new page in a flipbook. */
        function gameLoop() {

            /* We can make sure the game runs no faster than 30 frames per second
            by measuring the current time (using performance.now()), and seeing
            if it has been more than 1/30th of a second since the last time we
            updated the screen. `performance.now()` is a timer that records the
            number of milliseconds since (roughly) when the page loaded. */
            const now = performance.now();

            if (now - config.lastTime < config.fps) {
                /* If it has been fewer than 1/30th of a second since the last time
                we updated the screen, we will schedule this "gameLoop" function
                to be called on the next "animation frame," and check then.
                By writing `return;`, we exit the function immediately. */
                requestAnimationFrame(gameLoop);
                return;
            }

            /* If we get to this line, that means we didn't hit the `return;` in the
            condition above, and it means that more than 1/30th of a second has
            passed since the last time we updated the screen. So we'll proceed to
                A) record the current time (so we can continue tracking frame rate), and
                B) proceed to update the game state and more.

            We finish this function by passing a reference to the `gameLoop` function
            back to `requestAnimationFrame`, so that our function is called again the
            next time the browser is ready to update the screen. */
            config.lastTime = now;
            updatePlayerPosition();
            castRays();
            drawMinimap();
            requestAnimationFrame(gameLoop);
        }

        /* Once called, the gameLoop will actually schedule its own follow-up calls
        as needed. However, we have to manually invoke it once to get things going. */
        gameLoop();
    </script>
</body>

</html>